\documentclass[british,compsoc]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{array}

\makeatletter

\newcommand{\noun}[1]{\textsc{#1}}

\@ifundefined{showcaptionsetup}{}{
 \PassOptionsToPackage{caption=false}{subfig}}
\usepackage{subfig}
\makeatother

\usepackage{babel}
\usepackage{algpseudocode}
\usepackage{algorithm}

\begin{document}

%\title{Compositional design of asynchronous circuits \\
%from behavioural concepts}

\title{High-level asynchronous concepts at the interface between analogue and digital worlds}
\author{Jonathan Beaumont, Andrey Mokhov, Danil Sokolov, Alex Yakovlev\\
\texttt{\{j.r.beaumont, andrey.mokhov, danil.sokolov, alex.yakovlev\}@ncl.ac.uk}\\
\emph{School of Electrical and Electronic Engineering, Newcastle University,
UK}}

\maketitle

\begin{abstract}
Asynchronous circuits are becoming increasingly important in
system design for Internet-of-Things, where they orchestrate
the interface between big synchronous computation components
and the analogue environment, which is inherently asynchronous
and has high uncertainty with respect to power supply,
temperature and long-term ageing effects.
However, wide adoption of asynchronous circuits by industrial users is
hindered by a steep learning curve for asynchronous control models,
such as Signal Transition Graphs, that are developed by the academic
community for specification, verification and synthesis of
asynchronous circuits.

In this article we introduce a novel high-level description language
for asynchronous circuits, which is based on behavioural
\textit{concepts} -- high-level descriptions of asynchronous circuit
requirements, that can be shared, reused and extended by users,
and can be automatically translated to Signal Transition Graphs for
further processing by conventional asynchronous and synchronous EDA tools,
such as \noun{Petrify} and \noun{Mpsat}.
Our aim is to simplify the process of capturing system requirements in the
form of a formal specification, and to promote behavioural concepts as a
means for design reuse. The proposed design flow is fully automated in
open-source toolsuite \noun{Workcraft}, and is applied to the development of
an asynchronous power regulator.
\end{abstract}

\sloppy
\thispagestyle{empty}

\section{Introduction}

Analogue and mixed-signal circuits become more tightly integrated with
digital systems, in particular in mobile and autonomous applications,
such as wearable consumer electronics and self-powered Internet-of-Things
nodes, where it is essential to have intelligent timing control and power
regulation~\cite{7287733}\cite{talbot2016holistic}\cite{6241632}.
An on-chip power management system is an illustrative example: it relies
on analogue circuitry for power regulation and conversion, and its behaviour
is characterised by many operating modes with complex interplay and
high-level decision logic that is digitally controlled.
Asynchronous circuits are event-driven, i.e. they react to changes
in a system at the rate they occur~\cite{sparso2001principles}.
This makes them particularly useful for interacting with analogue world,
where the ability to quickly respond to non-digital input, e.g.
dynamically changing loads across the chip, is essential for reliable
operation and efficiency~\cite{2008_audy_isscc_tutorial}.

Signal Transition Graphs~(STGs)~\cite{Chu_1987_phd}\cite{Rosenblum_1985_tpn}
are commonly used for the specification,
verification and synthesis of asynchronous control circuits as they are
supported by multiple EDA tools, such as \noun{Petrify}~\cite{Cortadella},
\noun{Mpsat}~\cite{khomenko2004detecting}, \noun{Versify}~\cite{i1997formal},
\noun{Workcraft}~\cite{2007_poliakov_workcraft}\cite{Workcraft_website}, and others.
These tools take an STG specification of a complete controller and can
formally verify its correctness, as well as synthesise an asynchronous
circuit implementation that is \emph{speed-independent}, i.e. guaranteed
to work correctly regardless of component delays~\cite{Muller_1959_ts}.
Such a monolithic approach to designing asynchronous circuits has
poor scalability: as the system grows in complexity its monolithic
specification becomes challenging to comprehend and debug. The problem
becomes particularly severe when designing multi-mode systems, such as
power regulators, where capturing all aspects of system behaviour in a
consistent specification is a major design challenge~\cite{2014_sokolov_ftfc}\cite{sokolov2015design}.
The STG models of components and operating modes are difficult to reuse
when designing other specifications, and thus each new design must be built
from the ground up. This further adds to the design time, hence making
asynchronous circuits costly for use in industry.

In this paper we address this issue by proposing a new method for design
of asynchronous circuits based on \emph{behavioural concepts}.
The method splits a specification into several parts corresponding
to operational modes of the circuit (\emph{scenarios}). The features,
constraints and requirements of each scenario (\emph{concepts}),
are described in a formal notation, which we implemented as a domain
specific language embedded in Haskell~\cite{1996_hudak_dsl}. Concepts can
be defined at several levels; specifically, we give examples of signal-,
gate- and protocol-level concepts. It is possible to compose basic concepts
into more complex ones, thus supporting the design reuse at the level of system
specification.
%Commented out as I'm not sure we are actually talking about this in the paper:
%Scenarios of reconfigurable systems~\cite{microadapt}
%can also be parameterised by run-time parameters (e.g., available
%energy budget) or design-time ones (e.g., the number of processing
%cores in a Network-on-Chip network), therefore concepts should also
%support parameterisation.
Concepts can be automatically translated into equivalent STGs and
formally verified using standard tools, e.g. \noun{Workcraft}.
When all scenarios have been translated to STGs and verified, they can be
combined to produce a complete specification, and synthesised into an
asynchronous circuit implementation targeting a chosen technology library.
%Commented out, as this is probably too detailed for the intro.
%This step will also be automated,
%and will offer \emph{templates} for common scenario ordering requirements,
%such as mode switching sequences and start-up scenarios.

Our contributions are as follows:
\begin{itemize}
  \item We introduce asynchronous concepts as a specification
  language in \S\ref{sec:Concepts} and compare it to STGs in
  \S\ref{sec:Circuit-specification-with}.
  \item We present an algorithm for translating concepts to STGs
  and integrate it into our open-source software toolsuite \noun{Workcraft},
  \S\ref{sec: interop-with-stg}.
  \item We demonstrate the proposed design method on a case study of an
  asynchronous power regulator, \S\ref{sec:case-study}.
\end{itemize}

\noindent
We start with a motivational example in \S\ref{sec:Motivating Example}, review related work
in \S\ref{sec:related-work}, and discuss future research in \S\ref{sec:conclusions}.

%Designing a controller for an analogue circuit using this method can
%be beneficial. Any of the partial knowledge we have about any casual
%relationships between events in the environment can be naturally modelled
%as concepts. When composed with other concepts describing these relationships
%and concepts describing the control which reacts to the environment,
%a model will be produced which shows how the environment and the control
%system interacts.

%The idea is that our approach should reduce the complexity of designing
%asynchronous circuits, so the number of errors should be reduced,
%and easier to find and correct. This will in turn reduce the design
%time, and make asynchronous circuits more desirable for industry, so
%asynchronous circuits can be used in devices more commonly.

%The presented approach is automated as a Haskell tool~\cite{2016_concepts_github}.
%This parses concepts and uses them to produce scenario STGs. We aim to implement
%combination of scenarios in the tool in the future.
%STGs produced, either scenario or full system, are viewed,
%edited, simulated, verified and synthesised using the open-source \noun{Workcraft}
%framework~\cite{2007_poliakov_workcraft}, which features back-end tools \noun{Petrify}
%and \noun{Mpsat} to perform these operations.

%In this paper, we use real life industrial
%example of a buck converter~\cite{2014_sokolov_ftfc} to show our
%design flow, and test this design approach.
%\vspace{-2mm}

\section{Motivating Example: Buck Converter\label{sec:Motivating Example}}

On-chip power management is essential for energy efficiency and reliability of
IoT computation nodes~\cite{7287733}. Power management units need to interface
with the analogue part of the system for sensing and controlling it, and can
benefit from asynchronous implementation that allows them to react to changes
in the system at the rate they occur, instead of sampling various analogue
parameters by clock, which is both slow and energy-wasteful~\cite{2014_sokolov_ftfc}.

In this section we first provide the background on asynchronous buck
converters~\S\ref{sub:buck}, our main motivation example and case study.
Buck converters rely on analogue circuitry for power regulation and
conversion and their behaviour is typically characterised by many operating
modes with complex interplay and high-level decision logic that is digitally
controlled.
We then discuss challenges arising in the design of asynchronous buck converters
with Signal Transition Graphs~(STGs)~\cite{Chu_1987_phd}\cite{Rosenblum_1985_tpn},
a commonly used mathematical model for the specification of asynchronous
circuits~\S\ref{sub:Monolithic}.
Finally, we outline our new design approach~\S\ref{sub:new-way} wherein the
behaviour of an asynchronous buck converter is decomposed into simple
behaviours, that we later refer to as \emph{concepts}. The approach is
described on an intuitive level, and will be formalised in the next
section~\S\ref{sec:Concepts}.

\begin{figure}[t]
\begin{centering}
\subfloat[\label{fig:buck-schematic}Schematic (digital control in analogue environment).]
{\includegraphics[scale=0.7]{Images/schematic-buck}}
\par
\subfloat[\label{fig:buck-spec}Informal description of three behavioural scenarios.]
{\includegraphics[scale=0.6]{Images/spec-buck}}
\par
\end{centering}
\protect\caption{\label{fig:buck}Buck converter and its informal description.}
\end{figure}

\subsection{Background on buck converters\label{sub:buck}}

Our motivating example comes from the power management domain, a
\emph{multi-scenario power regulator}~\cite{2014_sokolov_ftfc}.
A basic power regulator comprises an analogue buck and a digital controller,
as shown in Figure~\ref{fig:buck-schematic}. The controller operates
the power regulating PMOS and NMOS transistors of the buck~(using \textsf{$gp$}
and \textsf{$gn$} outputs) as a reaction to \emph{under-voltage}~(UV),
\emph{over-current}~(OC) and \emph{zero-crossing}~(ZC) conditions~(\textsf{$uv$},
\textsf{$oc$}, and \textsf{$zc$} inputs, respectively). These conditions
are detected by a set of sensors that compare the measured current and voltage
with some reference values~(\textsf{V\_ref}, \textsf{I\_max}, \textsf{I\_0}).
Note that in order to avoid a short-circuit, the PMOS and NMOS transistors of
the buck must never be \noun{On} at the same time. Therefore, the controller
is explicitly notified~(by \textsf{$gp\_ack$} and \textsf{$gn\_ack$})
when the power transistor threshold levels~(\textsf{V\_pmos} and \textsf{V\_nmos})
are crossed.

The operation of a power regulator is usually described in an intuitive,
but rather informal way, e.g. by enumerating the possible sequences
of detected conditions and describing the intended reaction to these
events, as shown in Figure~\ref{fig:buck-spec}. The diagram shows
that UV should be handled by switching the NMOS transistor \noun{Off}
and PMOS transistor \noun{On}, while OC should revert their state~--
PMOS \noun{Off} and NMOS \noun{On}~(ZC~absent scenario). Detection of
the ZC after UV does not change this behaviour~(ZC~late scenario).
However, if ZC is detected before UV then both the PMOS and NMOS transistors
remain \noun{Off} until the UV condition~(ZC~early scenario).

\begin{figure}[t]
\begin{centering}
\includegraphics[scale=0.23]{Images/stg-buck}
\par
\protect\caption{\label{fig:Monolithic-buck}STG specification of a simple buck converter.}
\par\end{centering}
\end{figure}

\subsection{Monolithic STG-based design approach\label{sub:Monolithic}}

Using the informal description of three behavioural scenarios, the designer can
produce a formal specification, typically a monolithic STG describing the
complete behaviour of the circuit. Figure~\ref{fig:Monolithic-buck} shows such
a monolithic STG specification for the simple buck controller described above.
Nodes of the STG correspond to signal rising ($+$) and falling ($-$) transitions,
arcs model \emph{causality}, parallel branches correspond to concurrency, and
a circle \emph{place} with a black dot (\emph{token}) represents the choice of
the current scenario. We formally introduce STGs
in~\S\ref{sec:Circuit-specification-with}.

This STG is moderately large and captures all three scenarios by overlaying
their common parts. In the monolithic design approach, the designer starts with
a blank page and manually inserts signal transitions and the connections between
them according to the informal description of the system's operation. With
there being several scenarios, the designer could choose to design each
separately, and then manually compose these taking advantage of the
similarities between the scenarios.

In the event that a designer needs to add or remove signals or correct a fault, editing can become difficult, due to the complexity and size. This can lead to
further faults, and several iterations of design and tests until the new feature is added and deemed to be working correctly.

A designer may even have to start from a
blank page in some cases, unable to reuse any of the previous design. The larger and more complex an STG is, and the more signals there are, the more difficult it is to comprehend,
debug and edit. This can slow the design process of a circuit, which is undesirable in an industry where the time for a device to move from conception to market is becoming critical, and ever shorter~\cite{2014_sokolov_ftfc}\cite{sokolov2015design}.

\subsection{Towards high-level asynchronous concepts\label{sub:new-way}}
In an attempt to streamline the design process, we aimed to find a way to
create STGs which allows editing and reuse at various stages of the design.
This way, if something needs to be corrected, this can be done to a small part,
but we can reuse everything that works correctly. These parts can then be
composed to produce a full STG which contains the corrections, with a minimum
amount of time spent making the corrections.

This led us to take the example of a simple buck converter, and compare what
the STG shows, and what the description of operation of the system, in
particular its signals, is. This allowed us to view interactions between
certain signals which may not be obvious, but without which the STG would not
be a correct representation of the design. For example,
Figure~\ref{fig:stg-breakdown} shows one scenario of the simple buck converter
with some points of interest highlighted.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.225]{Images/stg-breakdown}
\par
\protect\caption{\label{fig:stg-breakdown}ZC absent scenario STG showing points of interest}
\par\end{centering}
\end{figure}

Studying this STG shows that there are some high-level signal interactions that
we can identify:
\begin{itemize}
\item High levels of $uv$ and $oc$ are mutually exclusive; indeed, $uv$ goes
high (transition $uv+$) only after $oc$ goes low (transition $oc-$), and vice
versa.
\item High levels of $gp$ and $gn$ are also mutually exclusive.
\item Signals $gp$ and $gp\_ack$ form a handshake, i.e. there is a cycle
$gp+ \rightarrow gp\_ack+ \rightarrow gp- \rightarrow gp\_ack-$ etc.
\item Signals $gn$ and $gn\_ack$ also form a handshake.
\end{itemize}

These interactions are described in the operation description by the fact that
$uv$ and $oc$ indicate opposite conditions in the circuit and will naturally be
mutually exclusive, while $gp$ and $gn$ are used to switch PMOS and NMOS
transistors respectively, and switching these transistors \noun{On} at the same
time will cause a short circuit and is therefore prohibited. Signals $gp\_ack$
and $gn\_ack$ are used to acknowledge the state of these transistors, and thus
always follow $gp$ and $gn$, respectively, forming two separate handshakes.

Knowing this information means that we can describe these protocols once, and
include them in the design of any circuit involving these signals. Any other
interactions between any of these signal will be subject to these protocols,
which will prevent circuit breaking bugs in the testing phase. For example, an
interaction involving $gp$ will ensure that it is never set high at
the same time as $gn$, as otherwise the mutual exclusion will not hold.

If one of these signals is removed, then the protocols that this affects can
be removed, but the unaffected protocols can continue to be used, avoiding a
major re-design which may happen when using the STG-based monolithic approach.

With this idea in mind, we need to find a way to describe these protocols, as
well as other signal interactions, in order to ensure that each different
interaction can be edited without needing to change every single interaction.

%% + Here is the problem we are solving
%%
%%
%%
%%+ STGs are a conventional specification model, STGs tend to get very large and complex for real-life circuits (show simple-buck example STG)
%%
%%
%%
%%+ STGs mix many different concerns in one single graph -- show how one could split the specification into what we call concepts.
%%
\section{Concepts \label{sec:Concepts}}

%\vspace{-2mm}


In this section we formally introduce \emph{concepts} that we propose
to employ for the specification of asynchronous circuits. Below we
list (fairly standard) definitions and notational conventions that
are used throughout the paper.

We use $\mathbb{B}$ to denote the set of Boolean values $\{0,1\}$.
Given two Boolean functions $f:X\rightarrow\mathbb{B}$ and $g:X\rightarrow\mathbb{B}$
with the same domain $X$, we lift Boolean operators (disjunction~$\vee$,
conjunction~$\wedge$, implication $\Rightarrow$, etc.) in the usual
manner: $h=f\vee g$ means $h(x)=f(x)\vee g(x)$ for all $x\in X$,
etc. Furthermore,~$\mathbf{0}$ and~$\mathbf{1}$ stand for constant
Boolean functions that discard their input and return values $0$
and $1$, respectively.

A\emph{ monoid} is a set $M$ and a binary operation $\diamond:M\times M\rightarrow M$
satisfying two axioms:
\begin{itemize}
\item Identity: $e\diamond a=a\diamond e=a$ for any $a\in M$, where $e\in M$
is the \emph{identity element} of the monoid.
\item Associativity: $a\diamond(b\diamond c)=(a\diamond b)\diamond c$ for
all $a,b,c\in M$.
\end{itemize}
Monoid is the simplest mathematical structure that captures the notions
of \emph{emptiness} and \emph{composition}. The concepts introduced
in this section form \emph{commutative monoids}: they have identity
elements corresponding to empty specifications, and can be composed
to build complex concepts from simpler ones. The order of composition
does not matter, i.e., the concepts commute: $a\diamond b=b\diamond a$
for all $a,b\in M$.

%\vspace{-3mm}



\subsection{Abstract concepts}

%\vspace{-3mm}


We first describe \emph{abstract concepts} that we use as building
blocks for developing \emph{domain specific concepts}, such as those
related to asynchronous circuits (Section~\ref{sub:Concepts-for-asynchronous}).


Abstract concepts are parameterised by finite sets of \emph{states}
$S$ and \emph{events} $E$. The \emph{initial state concept} captures
all possible (or \emph{permitted}) initial states of the system. In
the most general form it is a function
\[
\mathsf{initial}:S\rightarrow\mathbb{B}
\]
that given a state $s\in S$ returns $1$ if $s$ is an initial state
and $0$ otherwise. In practice this concept is often realised as
a membership test of a set of initial states~$I\subseteq S$, i.e.
$\mathsf{initial}(s)=s\in I$. However, we prefer the functional form
because it is more abstract and permits other, often more efficient
realisations. Note that~$\mathbf{0}$ and~$\mathbf{1}$ have natural
interpretations as initial concepts: they correspond to systems with
no initial states, and systems where any state can be initial, respectively.
Initial state concepts form a commutative monoid with the identity
element~$\mathbf{1}$ and the composition operation~$\wedge$. Intuitively,
if a system comprises two subsystems then its initial state should
satisfy constraints imposed by both subsystems, hence the conjunction
operator.

The \emph{event excitation concept} captures all states wherein a
given event can occur (or is \emph{excited}). In the most general
form it is a function
\[
\mathsf{excited}:E\times S\rightarrow\mathbb{B}
\]
that given an event $e\in E$ and a state $s\in S$ checks whether
$e$ is excited in $s$. In practice this concept is often realised
using \emph{interpreted graph models} such as Finite State Machines
and Petri Nets~\cite{Cortadella}, Conditional Partial Order Graphs~\cite{CPOG1},
and others. A partial application of the excitation function is often
useful: $\mathsf{excited}(e)$ captures all states where event $e$
is excited; for example, if $\mathsf{excited}(e)=\mathbf{0}$ then
$e$ is never excited or \emph{dead}. Event excitation concepts also
form a commutative monoid with~$e=\mathbf{1}$ and~$\diamond=\wedge$.
This definition corresponds to the \emph{parallel composition} operation,
a standard notion for many behavioural models~\cite{PCOMP}.

Some states may be impossible or undesirable during the normal system
operation. To express this we use the \emph{invariant concept}, which
captures all \emph{correct} or \emph{permitted} states of the system.
A typical use case for invariant concepts is to specify assertions
or assumptions about the system state space, that may by verified
via model checking and/or used for optimising the implementation.
In the most general form an invariant concept is a function
\[
\mathsf{invariant}:S\rightarrow\mathbb{B}
\]
that given a state $s\in S$ returns $1$ if $s$ is permitted by
the invariant and $0$ otherwise. Note that if for some state $s$
the initial concept $\mathsf{initial}(s)$ holds but the invariant
$\mathsf{invariant}(s)$ does not hold, then the specification is
\emph{contradictory} and cannot be satisfied by any implementation.
We therefore usually assume that $\mathsf{initial}(s)\Rightarrow\mathsf{invariant}(s)$
holds for all $s\in S$. Similarly, invariant concepts form a commutative
monoid with~$e=\mathbf{1}$ and~$\diamond=\wedge$. Intuitively,
if a system comprises two subsystems then its states should be permitted
in both of the subsystems.

One can derive other useful concepts from the three concepts described
above, for instance,
\[
\mathsf{silent}(e,s)=\overline{\mathsf{excited}(e,s)}
\]
captures all states $s\in S$ when a given event $e\in E$ cannot
occur. Furthermore, one can define other useful concepts that cannot
be derived from the above, e.g., the \emph{execution concept} capturing
the effects that different events have on the system state. Due to
space limitations we only consider the three concepts defined above
and their derivatives.

All described concepts form monoids, hence their combinations are
trivially monoids too. It is therefore convenient to consider triples
of concepts $(\mathsf{initial},\mathsf{excited},\mathsf{invariant})$
with $(\mathbf{1},\mathbf{1},\mathbf{1})$ representing the \emph{empty
specification}, and composition $(\mathsf{initial}_{1},\mathsf{excited}_{1},\mathsf{invariant}_{1})\diamond(\mathsf{initial}_{2},\mathsf{excited}_{2},\mathsf{invariant}_{2})$
defined as $(\mathsf{initial}_{1}\diamond\mathsf{initial}_{2},\mathsf{excited}_{1}\diamond\mathsf{excited}_{2},\mathsf{invariant}_{1}\diamond\mathsf{invariant}_{2})$.
Importantly, composition of two non-contradictory specifications is
always non-contradictory, that is if both $\mathsf{initial}_{1}(s)\Rightarrow\mathsf{invariant}_{1}(s)$
and $\mathsf{initial}_{2}(s)\Rightarrow\mathsf{invariant}_{2}(s)$
hold for all states $s\in S$, then $\mathsf{initial}_{1}(s)\diamond\mathsf{initial}_{2}(s)\Rightarrow\mathsf{invariant}_{1}(s)\diamond\mathsf{invariant}_{2}(s)$
holds too.

%\vspace{-3mm}



\subsection{Concepts for asynchronous circuits\label{sub:Concepts-for-asynchronous}}

%\vspace{-2mm}


We now introduce concepts which are specific for the domain of asynchronous
circuits and express them using the abstract concepts defined above.

\textbf{\label{signal-level}Signal-level concepts:} States and events of an asynchronous
circuit are parameterised by a fixed set of signals $A$. A state
$s\in S$ is an assignment of Boolean values to signals, i.e. a function
$s:A\rightarrow\mathbb{B}$, while an event $e\in E$ is a \emph{signal
transition}, i.e. a pair $e:A\times\mathbb{B}$ comprising a signal
$a\in A$ and the value of the signal \emph{after} the transition
occurs. We call transitions $(a,0)$ and $(a,1)$ \emph{falling} and
\emph{rising}, respectively, and denote them by $a^{-}$ and $a^{+}$
for brevity.

The following two predicates are very useful for constructing concepts:
\[
\begin{array}{ccc}
\mathsf{before} & \!\!\!\!:\!\!\!\!\! & E\times S\rightarrow\mathbb{B}\\
\mathsf{after} & \!\!\!\!:\!\!\!\!\! & E\times S\rightarrow\mathbb{B}
\end{array}
\]
A state $s\in S$ is said to be \emph{before} a transition $(a,b)\in E$
if $s(a)\neq b$, i.e. in state $s$ signal $a$ has a value which
is different from the resulting value of the transition. Similarly,
$s$ is \emph{after} $(a,b)$ if $s(a)=b$ (the transition has already
occurred).

We are now ready to define an excitation concept called \emph{consistency}~\cite{Cortadella}:
\[
\mathsf{consistency}=\mathsf{before}
\]
This concept captures the requirement that in a consistent asynchronous
circuit a signal transition can only be excited in states that are
before it.

Another key concept in asynchronous circuits is \emph{causality}:
we say that a transition $\mathit{effect}\in E$ causally depends
on transition $\mathit{cause}\in E$, denoted as
\[
\mathsf{causality}(\mathit{cause},\mathit{effect}):E\times S\rightarrow\mathbb{B}
\]
 if $\mathit{effect}$ can occur only in states that are after $\mathit{cause}$.
This is an excitation concept, which can be expressed as follows:
\[
\mathsf{causality}(\mathit{cause},\mathit{effect})(e)\!=\!\begin{cases}
\mathbf{1} & \mathit{if}\, e\neq\mathit{effect}\\
\mathsf{after}(cause) & \mathit{otherwise}
\end{cases}
\]
In words, we do not add any constraints to events $e\in E$ that are
distinct from $\mathit{effect}$, but $\mathit{effect}$ is constrained
to occur only after $\mathit{cause}$. Note that function $\mathsf{after}$
is used in the partially applied form. We will use a short-hand notation
\[
\mathit{cause}\rightsquigarrow\mathit{effect}
\]
for the causality concept for convenience.

While this concept is called \emph{causality}, this doesn't necessarily imply timings, such as any $\mathit{cause}$ transition immediatley forcing the
$\mathit{effect}$ transition it applies to. Causality can be used in order to list all possible $\mathit{cause}$ transitions which need to occur in order
for an $\mathit{effect}$ transition.

For example, one can compose two causality concepts using the monoid composition.
\[
a\rightsquigarrow c\ \diamond\ b\rightsquigarrow c
\]
corresponds to so-called AND-causality: event $c$ can only occur
after both $a$ and $b$ have occurred. Specifying OR-causality is
slightly more tricky:
\[
\mathsf{orCausality}(a,b,c)(e)=\begin{cases}
\mathbf{1} & \mathit{if}\, c\neq\mathit{e}\\
\mathsf{after}(a)\vee\mathsf{after}(b) & \mathit{otherwise}
\end{cases}
\]
Event $c$ is thus excited after at least one cause has occurred.

\textbf{Gate-level concepts:} Using the causality concept we can express
the behaviour of gates in asynchronous circuits. For example, a \emph{buffer}
is a gate with one input signal $a\in A$ and one output signal $b\in A$,
whose output transitions causally depend on the input ones:
\[
\mathsf{buffer}\, a\, b=a^{+}\rightsquigarrow b^{+}\ \diamond\ a^{-}\rightsquigarrow b^{-}
\]
An \emph{inverter} has a similar conceptual specification, but the
output transition is inverted:
\[
\mathsf{inverter}\,a \,b=a^{+}\rightsquigarrow b^{-}\ \diamond\ a^{-}\rightsquigarrow b^{+}
\]
An \emph{SR-Latch} has two input signals, $s$ and $r$ each of which cause differing transitions with the output, $q$:
\[
\mathsf{SRLatch}\,s \,r \,q=s^{+}\!\rightsquigarrow\! q^{+}\ \diamond\ r^{+}\!\rightsquigarrow\! q^{-}\ \diamond\ s^{-}\!\rightsquigarrow\! q^{-}\ \diamond\ r^{-}\!\rightsquigarrow\! q^{+}
\]
This can be described as, the\emph{set} signal, $s$ when active, or high, will cause the gate to latch a high state, outputting this with signal $q$ being high. Conversely, the \emph{reset} signal, $r$, when active, or high, will cause the gate to latch a low state, and the output $q$ will be low in this case.
Another way of specifying this gate using concepts is to use the buffer and inverter concepts defined above, as the signals $s$ and $q$ have an interaction the same as a buffer, and signals $r$ and $q$ interaction is the same as an inverter.
\[
\mathsf{SRLatch}\,s \,r \,q=\mathsf{buffer}\,s \,q \ \diamond\ \mathsf{inverter}\,r \,q
\]
A \emph{C-element} is a gate with two inputs $a$ and $b$ and one
output~$c$, which synchronises input transitions:
\[
\mathsf{cElement}\,a \,b \,c=a^{+}\!\rightsquigarrow\! c^{+}\ \diamond\ b^{+}\!\rightsquigarrow\! c^{+}\ \diamond\ a^{-}\!\rightsquigarrow\! c^{-}\ \diamond\ b^{-}\!\rightsquigarrow\! c^{-}
\]
In words, the rising output transition $c^{+}$ causally depends on
both $a^{+}$ and $b^{+}$, and the falling output transition $c^{-}$
causally depends on both $a^{-}$ and $b^{-}$. An alternative way
to express the same concept is to reuse the buffer concept:
\[
\mathsf{cElement}\,a \,b \,c=\mathsf{buffer}\,a \,c \ \diamond\ \mathsf{buffer}\,b \,c
\]
Indeed, a C-element combines the constraints imposed on the output
transitions by two `virtual' buffers.

Behaviour of other gates can be similarly defined using concepts,
see our Haskell implementation~\cite{2016_concepts_github}.

\textbf{Protocol-level concepts:} In addition to gate-level concepts
described above it is often important to specify \emph{protocols}
of interaction between multiple gates, components or signals, as shown in the example scenario STG in section~\ref{sub:new-way}.

Here we demonstrate how one can use concepts to specify asynchronous handshakes
and mutual exclusion mechanisms.

Given two signals $a$ and $b$, a \emph{handshake} between them is
the following composition of causality concepts:
\[
\mathsf{handshake}\,a \,b=a^{+}\!\rightsquigarrow\! b^{+}\ \diamond\ b^{+}\!\rightsquigarrow\! a^{-}\ \diamond\ a^{-}\!\rightsquigarrow\! b^{-}\ \diamond\ b^{-}\ \rightsquigarrow\! a^{+}
\]
Intuitively, we have a two-way asynchronous communication channel,
where one party sends transitions $a^{+}$ and $a^{-}$ and the other
party responds by corresponding $b^{+}$ and $b^{-}$ transitions.
One can notice that the four causality concepts match those found
in the buffer and inverter concepts, which leads to an alternative
way to express a handshake between~$a$ and~$b$:
\[
\mathsf{handshake}\,a \,b=\mathsf{buffer}\,a \,b \diamond\mathsf{inverter}\,b \,a
\]
Indeed, this conceptual understanding of a handshake as being composed
from a buffer and an inverter is often used by circuit designers as
a convenient way of reasoning.

In order to specify the initial state of a handshake between signals~$a$
and~$b$, we can use the function $\mathsf{initialise}$.
For example, $\mathsf{initialise}\,a \,False$ sets the state of the signal
$a$ to $0$. We can compose an initial state concept with
the handshake concept as follows:
\[
\mathsf{handshake00}\,a \,b \!=\!\mathsf{handshake}\,a \,b \, \diamond\,\mathsf{initialise}\,a \,False \,\diamond \,
\]
\[
\mathsf{initialise}\,b \,False
\]
The resulting concept corresponds to a handshake between signals~$a$
and~$b$ that are both initially $0$.

The last important concept that requires an introduction is \emph{mutual
exclusion} between two signals~$a$ and~$b$:
\[
\mathsf{me}\,a \,b =a^{-}\rightsquigarrow b^{+}\ \diamond\ b^{-}\rightsquigarrow a^{+}\diamond\overline{\mathsf{after}\,a^{+} \, \wedge\mathsf{after}\,b^{+}\, }
\]
The concept comprises two parts: 1) in terms of causality, we say
that rising transitions $a^{+}$ and $b^{+}$ can only occur after
the opposite falling ones, 2) the initial states when $a=b=1$ are
forbidden. Taken together these two parts guarantee that $a$ and
$b$ are never set to $1$ at the same time, i.e. they are mutually
exclusive. We also add $\overline{\mathsf{after}\, a^{+} \, \wedge\mathsf{after}\ b^{+}\,}$
to the invariant.

We can now specify a \emph{mutual exclusion element}~\cite{2008_kinniment_synchronisation}
that receives asynchronous requests $r_{1}$ and $r_{2}$ to a shared
resource and grants access to it by corresponding mutually exclusive
signals $g_{1}$ and $g_{2}$:

%\vspace{-3mm}
{\small{}
\[
\mathsf{meElement}\'r_{1} \,r_{2} \,g_{1} \,g_{2} \,\!=\mathsf{\! buffer}\,r_{1} \,g_{1} \,\diamond\mathsf{buffer}\,r_{2} \,g_{2} \,\diamond\mathsf{me}\,g_{1} \,g_{2} \,
\]
}{\small \par}

%\vspace{-3mm}

\subsection{Signal types}

Specifying signal types is important when designing asynchronous circuits. How signals of different
types interact is knowledge required for verification properties to be held, and for synthesis.

The information of which signals are \emph{inputs}, \emph{outputs} or \emph{internals} can further
speed the design process. Primarily, in the process of translating concepts, the resulting STGs can
be more quickly used for testing, verification, synthesis, etc. Without specifying the types, this
would require signals types to declared manually in the resulting STG.

Signal types, or \emph{interfaces}, in concept-form, are described by listing the signals based on type:
{\small{}
\[
\mathsf{\! inputs}\,[a, b]
\]
}{\small \par}
{\small{}
\[
\mathsf{\! outputs}\,[p]
\]
}{\small \par}
{\small{}
\[
\mathsf{\! internals}\,[x, y, z]
\]
}{\small \par}

As with all concepts, interface concepts can be composed with eachother, or with any
other concept; signal-, gate- or protocol-level.

\section{Circuit specification with concepts \label{sec:Circuit-specification-with}}

%\vspace{-2mm}

Here we present a method for deriving a circuit specification
from a set of concepts that describe its different aspects. We focus
on specification of \emph{Speed-Independent}~(SI) circuits, which
is an important class of asynchronous circuits~\cite{Muller_1959_ts}
that work correctly regardless of the gates' delays, while the wires
are assumed to have negligible delays. Alternatively, one can regard
wire forks as isochronic and add wire delays to the corresponding
gate delays~(\emph{Quasi-Delay Insensitive}~(QDI) circuit class~\cite{Martin_1986_dc}).
A convenient formalism for specification of SI circuits is STGs~\cite{Chu_1987_phd,Rosenblum_1985_tpn},
which is a special kind of Petri nets~\cite{Petri_1962_phd} whose
transitions are associated with signal events.

%\vspace{-3mm}

\subsection{Petri nets and STGs}

%\vspace{-3mm}


Formally, a Petri net is defined as a tuple~$PN=\left\langle P,\, T,\, F,\, M_{0}\right\rangle $
comprising finite disjoint sets of \emph{places~}$P$ and \emph{transitions~}$T$,
\emph{arcs} denoting the flow relation~$F\subseteq\left(P\times T\right)\cup\left(T\times P\right)$
and \emph{initial~marking~}$M_{0}$. There is an arc between~$x\in P\cup T$
and~$y\in P\cup T$ iff $\left(x,y\right)\in F$. The \emph{preset}
of a node $x\in P\cup T$ is defined as $\bullet x=\left\{ y\mid\left(y,x\right)\in F\right\} $,
and the \emph{postset} as $x\bullet=\left\{ y\mid\left(x,y\right)\in F\right\} $.
The dynamic behaviour of a Petri net is defined as a \emph{token~game},
changing marking according to the enabling and firing rules. A \emph{marking}
is a mapping~$M:\, P\rightarrow\mathbb{N}$ denoting the number of
\emph{tokens} in each place~($\mathbb{N}=\left\{ 0,1\right\} $ for
\emph{1-safe} Petri nets). A transition $t$ is \emph{enabled} iff
$\forall p,p\in\bullet t\Rightarrow M(p)>0$. The evolution of a Petri
net is possible by \emph{firing} the enabled transitions. \emph{Firing}
of a transition~$t$ results in a new marking $M'$ such that
\[
M'\left(p\right)=\left\{ \begin{array}{cc}
M(p)-1 & if\, p\in\bullet t\setminus t\bullet,\\
M(p)+1 & if\, p\in t\bullet\setminus\bullet t,\\
M(p)\,\,\,\,\, & otherwise
\end{array}\right.
\]
 for all $p\in P$.

An STG is a 1-safe Petri net whose transitions are labelled by signal
events, i.e. $STG=\left\langle P,\, T,\, F,\, M_{0},\,\lambda,\, Z,\, v_{0}\right\rangle $,
where $\lambda$ is a \emph{labelling~function}, $Z$ is a set of
\emph{signals} and $v_{0}\in\left\{ 0,\,1\right\} ^{\left|Z\right|}$
is a \emph{vector~of}~\emph{initial~signal~values}. The labelling
function $\lambda:T\rightarrow Z\pm$ maps transitions into \emph{signal~events}
$Z\pm=Z\times\left\{ +,-\right\} $. The signal events labelled $z+$
and $z-$ denote the transitions of signals $z\in Z$ from 0~to~1~(rising
edge), or from 1~to~0~(falling edge), respectively. The labelling
function does not have to be 1-to-1, i.e. transitions with the same
label may occur several times in the net. To distinguish transitions
with the same label and refer to them from the text an index $i\in\mathbb{N}$
is attached to their labels as follows: $\lambda\left(t\right)/i$,
where $i$ differs for different transitions with the same label.
STGs inherit the operational semantics of their underlying PNs, including
the notions of transition enabling and firing.

Graphically, the places are represented as circles, transitions as
text labels, consuming and producing arcs are shown by arrows, and
tokens are depicted by dots. For simplicity, the places with one incoming
and one outgoing arc are often hidden, allowing arcs~(with implicit
places) between transitions.

%\vspace{-3mm}

\subsection{Composition of concepts \label{sub:Comp-of-concepts}}

%\vspace{-3mm}


A single concept can be used to describe an initial state, invariant
states, a single event or a combination of these, yet describing some
protocols using this method can become long winded, as these can involve
multiple events. We make use of the monoid composition of concepts
to describe complex systems incrementally. Importantly we can mix
several levels of system description and refer to signal, gate and
protocol level concepts in one specification, depending on which level
is more convenient in a particular situation.

Consider the example of a C-element, which has signals $a$ and $b$ as inputs,
and signal $c$ is the output. The output of this C-element is connected to
each of the inputs via an inverter. This is a simple example of a complete
system, of a C-element with an environment, and will be used several
times as a simple example.

The following is the file using the code to describe the example using signal-level concepts, which can be passed into
the translation tool:

%\vspace{2mm}
\begin{minipage}[t]{1\columnwidth}%
\begin{flushleft}
$\,\mathsf{module}\, Concept \, \mathsf{where}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{import}\, Tuura.ConceptConcat$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{circuit :: (Eq a) =>}\, a \rightarrow a \rightarrow  a \rightarrow  CircuitConcept\,a$
$\begin{aligned}\mathsf{circuit}\,a \,b \,c=&\mathsf{\,interface}\,<> \mathsf{\, outputRise}<>\\
&\,\mathsf{inputFall}\,<>\,\mathsf{outputFall}<>\\
&\mathsf{\, inputRise}\,<>\,\mathsf{initialState}\\
\end{aligned}
$

$\,\mathsf{where}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{interface}=\mathsf{inputs}\,[a,b]<>\mathsf{outputs}\,[c]$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{outputRise}=\mathsf{rise} \,a\rightsquigarrow \mathsf{rise} \,c\,<>\, \mathsf{rise} \,b\rightsquigarrow \mathsf{rise} \,c$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{inputFall}=\mathsf{rise} \,c\rightsquigarrow \mathsf{fall} \,a \,<>\, \mathsf{rise} \,c \rightsquigarrow \mathsf{fall} \,b$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{outputFall}=\mathsf{fall} \,a \rightsquigarrow \mathsf{fall} \,c \,<>\, \mathsf{fall} \,b \rightsquigarrow \mathsf{fall} \,c$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{inputRise}=\mathsf{fall} \,c \rightsquigarrow \mathsf{rise} \,a \,<>\, \mathsf{fall} \,c\rightsquigarrow \mathsf{rise} \,b$
\par\end{flushleft}

\begin{flushleft}
$\begin{aligned}\mathsf{initialState}= & \, \mathsf{initialise}\,a \, False\,<>\,\mathsf{initialise}\,b \,False\,<> \\
 & \, \mathsf{initialise}\,c \,False \,
\end{aligned}
$
\par\end{flushleft}

\end{minipage}

%\vspace{2mm}


The first concepts in this list is the \emph{circuit} concept, defined as the composition of the following 5. This is the concept which will be translated.
The concepts defined after the \emph{where} describe certain operations of the system. The first four are named according to what they represent,
for example, \textsf{\textit{\emph{outputRise}}} describes the events which cause the output to rise. The final concepts defines
the initial states, necessary for the translation algorithm to produce an STG which is useable, as without the initial states, none of the signals will be
able to transition.

%The sixth concept composes all of the first
%5 concepts, and can be translated to the STG shown in Figure~\ref{fig:cElement STG composition}.
%The first four are named according to what they represent, for example,
%\textsf{\textit{\emph{outputRise}}}\textit{ }describes the events
%which cause the output to rise\textit{.} The fifth concept is the
%initial state concept. This is necessary for the algorithm to produce
%a scenario STG, as the STG produced will not be usable without knowing
%the states the signals will be in when the scenario is entered. The
%algorithm takes this concept and works out where tokens need to be
%placed in the STG produced.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/stg-cElement}
\par\end{centering}

\protect\caption{\label{fig:cElement STG composition}STG for the example system.}
\end{figure}

Note: The code demonstrated in this example is the format required to work with the tool.
For the purpose of clarity, in this document we will be changing some of the syntax when defining concepts.
We will omit the module declaration, and imports, as well as
the declaration of types for \emph{circuit}, as these are required, and as such will be included in all concepts.
\emph{rise} and \emph{fall} are used in the code to represent a high and low transition respectively.
We replace \emph{rise} with '+' and \emph{fall} with '-'. Finally, the diamond composition operator in code is both a '<' and '>' as
a diamond character is not a standard keyboard character. In this article, we will use $\diamond$ to denote composition.
All examples in this article are available in the
format used by the tool from it's GitHub repository~\cite{2016_concepts_github}.

This set of concepts is only one way of describing this C-element
and the environment. Another way could be to use gate-level concepts
and describe the environment explicitly. In this case the environment
allows the inputs to transition in the opposite direction to the output
$c$, as two inverters would. We can then compose this with the C-element
and the same initial state concept:

%\vspace{1mm}


\begin{minipage}[t]{1\columnwidth}%
$\begin{aligned}\mathsf{circuit} \,a \,b \,c=&\mathsf{\,interface}\diamond\mathsf{\,cElement}\,a \,b \,c \,\diamond\,\mathsf{environment}\\
&\diamond\,\mathsf{initialState}
\end{aligned}\\
$
$\mathsf{where}$\\
$\mathsf{environment}=\mathsf{inverter} \,c \,a \,\diamond\,\mathsf{inverter}\,c \,b$
\\
\end{minipage}
%\vspace{2mm}
This specification is equivalent to the previous one; indeed one can
prove this by rearranging the primitive concepts using the commutativity
and associativity axioms of the underlying commutative monoid. Consequently,
this specification will be translated to the same STG shown in Figure~\ref{fig:cElement STG  composition}.
Figure~\ref{fig:cElement-concepts} illustrates all the concepts
involved in this specification.

\begin{figure}[t]
\begin{centering}
\includegraphics[scale=0.62]{Images/c-element-circuit-redo}
%\includegraphics[scale=0.6]{Images/c-element-circuit}
\par\end{centering}

\protect\caption{\label{fig:cElement-concepts}Example system specified using concepts.}
\end{figure}


Finally, the designer can also rely on protocol-level concepts, producing
the following equivalent specification:
%\vspace{1mm}


\begin{minipage}[t]{1\columnwidth}%

$\\\begin{aligned}\mathsf{circuit}\,a \,b \,c=&\mathsf{handshake00}\,a \,c \,\diamond\,\mathsf{handshake00}\,b \,c \, \diamond\\
&\mathsf{inputs}\,[a,b] \,\diamond \mathsf{outputs}\,[c]
\end{aligned}$\\
\end{minipage}
%\vspace{2mm}


This example demonstrates that the presented formal notation for capturing
concepts is very flexible and provides the designer with a rich selection
of available levels of abstraction, which could be used not only for
deriving simplest possible specifications but also for cross-checking
the adequacy of specifications by \emph{refactoring} them according
to the composition laws.

%\vspace{-3mm}



\subsection{Multiple behavioural scenarios \label{sub:scenarios}}

%\vspace{-2mm}


So far we have only considered systems operating in a single behavioural
\textit{scenario} specified by a composition of concepts. However,
real-life systems often need to support multiple scenarios~ (e.g.,
start-up and normal operation, different power modes~\cite{microadapt},
etc.). This allows each individual scenario to be designed using concepts,
and tested individually to ensure they work correctly, before these
are combined to produce a full system specification.

To increase the re-usability of scenarios, which helps reduce design
time of future systems, this method supports the use of pre-designed
scenarios as concepts.

In some cases, a designer may find it easier to split the specification
of operational modes further than scenarios and design certain elements
separately. In this way, a model may be produced from concepts, which
may not be an operational mode on its own, but can be composed and
tested separately. Having several elements predefined
using concepts may become useful for quickly designing systems. A
predefined logic gate, for example, could be useful to quickly include
in any list of concepts when designing multiple scenarios. An STG
produced of this element can be referenced in a list of concepts by
name (provided that the definition is appropriately imported into
the current namespace). When a list of concepts is passed into the
STG translation algorithm, all referenced concepts are replaced by
the corresponding definitions.

%The process of combining scenarios is explained further in Section~\ref{sub:scenario-composition}

%\vspace{-3mm}


\section{Interoperability with STG based tools \label{sec: interop-with-stg}}

Concepts may be a useful way of specifying asynchronous circuits, but specifications need to be verified against certain properties to ensure they will work correctly, and once they are
deemed to be correct, they can then be synthesized to produce a circuit implementation. Several standard tools exist which automatically verify and synthesize specifications, such as
\noun{Petrify}~\cite{Cortadella} and \noun{Mpsat}~\cite{khomenko2004detecting}, however these are designed to work with STG specifications. Thus it is necessary to translate
concept specifications to STGs in order to be used with these tools.

In this section, we will discuss the algorithm which translates concepts to STGs. Once concepts have been translated, they can be composed and combined using tools, and this will also
be discussed.

%A method of synthesizing concepts directly also exists, which will be explained,giving more options to designers.

\subsection{Translating concepts to STGs \label {sub:translating}}

As discussed in~\ref{sub:Comp-of-concepts}, there are multiple ways of representing a specification as concepts.
When translating any concepts we pass them to an algorithm which begins by breaking down all concepts into a list of
signal-level concepts. As concepts are compositional, and gate- and protocol-level concepts are composed of signal-level concepts, this process is simple.
Interface concepts are used to set the signal types, and as such are not included in this part of the translation.

Using the example of a C-element with an environment, any representation mentioned in Section~\ref{sub:Comp-of-concepts} when passed into this
algorithm would initially produce the list of concepts
found in Figure~\ref{fig:c-element-concepts}.

%\vspace{2mm}
\begin{figure}[h]
\begin{minipage}[h]{1\columnwidth}%
\begin{center}
$\,a^{+}\rightsquigarrow c^{+}$
\par\end{center}

\begin{center}
$\,b^{+}\rightsquigarrow c^{+}$
\par\end{center}

\begin{center}
$\,c^{+}\rightsquigarrow a^{-}$
\par\end{center}

\begin{center}
$\,c^{+}\rightsquigarrow b^{-}$
\par\end{center}

\begin{center}
$\,a^{-}\rightsquigarrow c^{-}$
\par\end{center}

\begin{center}
$\,b^{-}\rightsquigarrow c^{-}$
\par\end{center}

\begin{center}
$\,c^{-}\rightsquigarrow a^{+}$
\par\end{center}

\begin{center}
$\,c^{-}\rightsquigarrow b^{+}$
\par\end{center}

\begin{center}
$\,\mathsf{initialise}\,a \,False $
\par\end{center}

\begin{center}
$\,\mathsf{initialise}\,b \,False $
\par\end{center}

\begin{center}
$\,\mathsf{initialise}\,c \,False $
\par\end{center}

\end{minipage}
\caption{Concepts for a C-element with environment\label{fig:c-element-concepts}}
\end{figure}
%\vspace{2mm}

With this list, we can now start to produce an STG. For this explanation, we will use images to illustrate the example, but the algorithm would produce an STG in the form of a \emph{.g}
file. This file type is compatible with all standard tools, such as \noun{Petrify}, \noun{Mpsat} and \noun{Workcraft}.

Initially the algorithm finds all signals in the system, and produces some \emph{consistency loops}. A consistency loop features both the high and low transitions of a signal, and places
in between. These loops are used to ensure that an STG satisfies the property of \emph{consistency}, which states that a signal transition can only be excited in states that are before
it~\cite{Cortadella}. The places are used to determine the current state of a signal, and each signal has it's own consistency loop. For the list of signal-level concepts, the first
part of the resulting STG to be produced is shown in Figure~\ref{fig:step-by-step1}.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.23]{Images/Step-by-step1}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:step-by-step1}The first step in translating concepts to an STG}

\par\end{centering}

\end{figure}

The next step is to start connecting the signal transitions in the order of the list of signal-level concepts. First of all, $\,a^{+}\rightsquigarrow c^{+}$. To represent this
in the STG, we need to connect the place after $a^{+}$ ($a_0$ in Figure~\ref{fig:step-by-step1}) which shows whether $a$ has already transitioned high or not, with the use of a
token, being present if $a^{+}$ has occured, absent if it has yet to occur. This is connected to the the transition of $c^{+}$. We use a read-arc to connect these, as if $a_0$ contains
a token, a read-arc will allow $c^{+}$ to transition without consuming the token, as consuming the token would block the $a^{-}$ transition, so consistency will not be held.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.23]{Images/Step-by-step2}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:step-by-step2}The second step in translating concepts to STGs}

\par\end{centering}

\end{figure}

All concepts like this, signal-level concepts, can be added to the STG in the same way. The STG following insertion of all signal-level concepts in the above list, before the \emph{initialise} concepts, will produce an STG as
shown in Figure~\ref{fig:step-by-step9}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.23]{Images/Step-by-step9}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:step-by-step9}The translated STG with all arcs added}

\par\end{centering}

\end{figure}

At this point, all that is left to add is the initial states. This involves placing tokens in relevant places in the STG. The initial state concepts are "$\,\mathsf{initialise}\,a \,False$",
"$\,\mathsf{initialise}\,b \,False$" and "$\,\mathsf{initialise}\,c \,False$". These detaul the initial states of all three signals is 0, and therefore we have to add a single token to places $a_0$,
$b_0$ and $c_0$. This will produce the fully translated STG, which will look as follows:

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.23]{Images/Step-by-step12}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:step-by-step12}The translated C-element with environment STG}

\par\end{centering}

\end{figure}

The \emph{.g} file containing this STG can be imported into \noun{Workcraft}, where it can be viewed, and will look similar to Figure~\ref{fig:step-by-step12}. This can be
resynthesized using \noun{Petrify} to produce a more compact and easier to read version of the STG, illustrated in Figure~\ref{fig:cElement STG}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.28]{Images/stg-cElement}
\par\end{centering}

\protect\caption{\label{fig:cElement STG}Resynthesized STG for the example system.}
\end{figure}

Both Figure~\ref{fig:step-by-step12} and Figure~\ref{fig:cElement STG} are a correct specification for the C-element with environment. Either of these can be used with
\noun{Workcraft} and existing tools. This allows a designer to visualize their designs as STGs, to test, verify and synthesize, and if there are any corrections or additions to be made
these can be done either with the concepts, which can be re-translated to view an updated STG, or to the STG directly.

%In some cases it may not be necessary to visualize a translated STG. A \emph{.g} file is used as an input with these tools, without having to import into \noun{Workcraft}. This can
%further quicken the process of specification using concepts. This also applies to synthesis, which can be performed using a tool such as \noun{Petrify} or \noun{Mpsat}.

%or using \emph{Direct Synthesis}, which is discussed in Section~\ref{sub:direct-synth}.

\subsection{Parallel composition}

With this method of translating concepts to STGs this allows alternative use of tools. While we can specify an entire scenario as concepts and translate this to an STG, it is also possible to
translate smaller collections of concepts, or even singular concepts, which are not necessarily a complete STG. These can be visualised, and then composed using
\emph{Parallel Composition}
within \noun{Workcraft} using an integrated tool \noun{Pcomp}~\cite{PCOMP}.

Using the example in Section~\ref{sub:Comp-of-concepts}, a C-element with environment, we can translate the $\mathsf{cElement}(e)$ and the two $\mathsf{inverter}(e)$ concepts
individually. Including the initial states, this would give us the STGs found in Figure~\ref{fig:IndividConceptStgs}.

\begin{figure}[h]
\begin{centering}
\subfloat[\label{fig:cElement}$\mathsf{cElement}(a,b,c)$]{\begin{centering}
\includegraphics[scale=0.23]{Images/C-element}
\par\end{centering}

}
\par\end{centering}

\begin{centering}
\subfloat[\label{fig:inverterca}$\mathsf{inverter}(c,a)$]{\begin{centering}
\includegraphics[scale=0.23]{Images/inverter(c,a)}
\par\end{centering}

}
\par\end{centering}

\begin{centering}
\subfloat[\label{fig:inverterba} $\mathsf{inverter}(c,b)$]{\begin{centering}
\includegraphics[scale=0.23]{Images/inverter(c,b)}
\par\end{centering}

}
\par\end{centering}

\protect\caption{\label{fig:IndividConceptStgs}Individual STG translations of concepts}
\end{figure}

These STGs can now be passed into \noun{Pcomp}~\cite{PCOMP}, which will compose them. The outcome of which will be the same as the concept composition, an STG the same as shown in
Figure~\ref{fig:cElement STG}.

The algorithm for the translation from concepts to STGs can be found in Algorithm~\ref{alg:translation}.]

\begin{algorithm}[h]
\begin{algorithmic}
\caption{Concepts to STG translation algorithm \label{alg:translation}}
\For {Each defined concept}
  \State \textbf{add} signal-level concepts \textbf{to} conceptList
\EndFor \\

//Create consistency loops
\For {Each signal in system}
  \State \textbf{define} signal as input/output/internal
  \State \textbf{add} transition \textbf{high}
  \State \textbf{add} transition \textbf{low}
  \State \textbf{add} place \textbf{signal-0}
  \State \textbf{add} place \textbf{signal-1}
  \State \textbf{connect} (transition \textbf{high}, place \textbf{signal-1})
  \State \textbf{connect} (place \textbf{signal-1}, transition \textbf{low})
  \State \textbf{connect} (transition \textbf{low}, place \textbf{signal-0})
  \State \textbf{connect} (place \textbf{signal-0}, transition \textbf{high})
\EndFor

\For {Each causlity concept}
  \State \textbf{connect-read}(place \textbf{following} cause, effect transition)
\EndFor

\For {Each initial state concept}
  \State \textbf{add-token}(place \textbf{signal-}value)
\EndFor

\end{algorithmic}
\end{algorithm}

\subsection{Scenario combination\label{sub:scenario-composition}}

As mentioned in~\ref{sub:scenarios}, concepts can be used in a composition to produce a scenario.
%which can be tested and verified separately to allow for easier changes and additions
%to smaller, less complex, specifications. However, when scenarios are tested and prove to work as required, and satisfy all necessary properties, they then need to be combined to
%produce a full system specification, so this can be tested and verified, and ultimately be synthesized to produce an implementation.

When combining scenarios, there are several things to consider in
how the scenarios fit together. Depending on the application,
%the circuit is being designed for
some scenarios may need to operate in certain
orders, for example, one scenario may exist simply to initialise the
circuit, therefore this scenario needs to run at start-up, before
any of the other scenarios, and then never be run again while the
system remains active.

To address this, when combining scenarios we aim offer some templates,
each of which can be used to combine scenarios in various orders.
With this the designer specifies in which ways the scenarios should
be combined, and if an order is needed, the order the scenarios should
be run from start up. The following are some examples of templates
that will be offered before scenarios are combined:

\textbf{Sequential:} Sequential combination will allow a designer
to select the order of all scenarios, so when combined, they will
run in a sequence. In this case, there may be a clear order in which
the scenarios may run, and this needs to be specified by the designer.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.45]{Images/sequential_combination}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:sequential_combination}An example of sequential combination}

\par\end{centering}

\end{figure}

\textbf{Concurrent:} In this case there is no order, but one or more
of the scenarios in a specification may run in parallel. This template
will combine the scenarios in a way that will allow concurrency to
occur, limited to requirements of the specification, for instance,
the number of scenarios that can be active at any one time, which
can be limited by the number of tokens available at once.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.45]{Images/concurrent_combination}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:concurrent_combination}An example of concurrent combination}

\par\end{centering}

\end{figure}

\textbf{Non-deterministic choice:} This template will combine the
scenarios in a way that allows any of the scenarios to run, but not
according to any order to deal with the lack of determinism in the
system, using one token which is used only by the running scenario,
and this is returned when the scenario completes.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.45]{Images/non_deterministic_combination}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:non_deterministic_combination}An example of non-deterministic combination}

\par\end{centering}

\end{figure}

There may be more complex requirements to combination, and it
is possible to combine some scenarios using one template, then including
the result in a combination with other scenarios using another template. For example, a
system which is non-deterministic may also have a scenario that runs
at start up. In this case, a designer could
combine all non-deterministic scenarios first, then combine the resulting
STG with the initialising scenario, setting the order so this runs
first.

This method of combination can allow for many possible scenario combination
styles, and more complex systems can be combined automatically, which
in comparison to manual combination, could reduce the number of errors
as well as design time.

%\subsection{Direct synthesis from concepts \label{sub:direct-synth}}
%
%It is possible to synthesise directly from STGs, which we call \emph{Direct Synthesis}. Direct synthesis is a method of producing an implementation directly from concepts, finding Boolean
%functions which are used to produce a logic gate implementation. There are some caveats to this however. Currently, it is suboptimal, and thus the functions it produces may not be the
%best possible implementation, but it may be a quicker method of finding an implementation. We will explain this algorithm in this section, and give a brief example.
%
%\subsubsection{Algorithm of direct synthesis}
%
%When finding an implementation for a specification, we need only concern ourselves with the output signals. The input signals, the environment, can not be
%controlled directly by a circuit, it merely reacts to the outputs, but we need to find a way of causing the outputs to changed based on the inputs. In this way we only need to find the
%Boolean equations for the output signals.
%
%Therefore, we take an output signal, $x$. With this, we start by finding all concepts in which a signal causes a low to high transition, also known as the set function, $x^{+}$, such as
%$p\rightsquigarrow x^{+}$, where p is any signal transition. We then record these signals only for $x^{+}$ in the form of a Boolean equation, where a low to high signal transition, such
%as $p^{+}$ would be recorded as simply $p$, and a high to low transition, $p^{-}$, would be recorded as $\bar{p}$. All signals which cause this output signal transition in this scenario
%will be combined using the \emph{AND} ($*$) operation.
%
%This is then repeated to find the equations for the opposite transition for this output signal, in this case the high to low transition, $x^{-}$, also known as the reset function. Following
%this, we can reduce these equations. First of all, by resolving some Boolean relations. A Boolean relation is when an equation contains several signals which are related, usually by a
%transition of one being assumed to occur after the transition of another~\cite{Cortadella}. For example, take a system with two input signals, $p$ and $q$, and an output signal $x$. If
%some concepts in this system are:
%
%\vspace{2mm}
%\begin{minipage}[t]{1\columnwidth}%
%\begin{center}
%$\,p^{+}\rightsquigarrow x^{+}$
%\par\end{center}
%
%\begin{center}
%$\,q^{+}\rightsquigarrow x^{+}$
%\par\end{center}
%
%\begin{center}
%$\,p^{+}\rightsquigarrow q^{+}$
%\par\end{center}
%
%\end{minipage}\vspace{2mm}
%
%The equation for $x^{+}$ will contain in some variation $p*q$. These concepts state that both $p^{+}$ and $q^{+}$ must occur before $x^{+}$ can occur. It also states, however,
%the timing assumption that $p^{+}$ occurs before $q^{+}$. It can therefore be assumed that $q^{+}$ shows that the $p^{+}$ transition has occurred, and can be removed from the
%Boolean equations.
%
%Further reductions can be performed on these equations using existing algorithms, which will remove any redundancies and simplify them. The set and reset functions for
%this signal can then be used for a logic implementation. Depending on the type of synthesis these can be used in different ways, for instance, C-element synthesis uses these set and
%reset functions as they are, but technology mapping combines these functions by negating only the signals in the reset function, not the equation itself, and then \emph{OR}-ing this
%with the set function of $x^{+}$. This can then be combined with an existing equation for $x$ from previous scenarios by \emph{OR}-ing this with the existing equation.
%
%This can be repeated for each output signal in the scenario, and for each scenario in the specification, and this will produce a full implementation for the system. An algorithm for Direct
%Synthesis is found in Algorithm~\ref{alg:direct-synth}
%
%\begin{algorithm}[h]
%\begin{algorithmic}
%\caption{Algorithm for direct synthesis \label{alg:direct-synth}}
%\For {Each scenario in system}
%  \For {Output signal $x$ in all output signals}
%    \For {Each signal transition $p$ that causes $x^{+}$}
%	\If {$p^{+}$}
%                \State setEq <- setEq $*$ $p$;
%          \Else
%	     \State setEq <- setEq  $*$ $\bar{p}$
%	\EndIf
%    \EndFor
%    \For {Each signal transition $p$ that causes $x^{-}$}
%         \If {$p^{+}$}
%                \State resetEq <- resetEq  $*$  $p$;
%          \Else
%	     \State resetEq <- resetEq  $*$  $\bar{p}$
%	\EndIf
%    \EndFor
%  \EndFor
%  \State reduce(setEq)
%  \State reduce(resetEq)
%\EndFor
%\end{algorithmic}
%\end{algorithm}
%
%\subsubsection{Example of direct synthesis}
%
%For this example we will use the same example as we have previously, the C-element with environment~(Figure~{\ref{fig:cElement-concepts}). In the case of a circuit for this example,
%the inputs $a$ and $b$ we cannot control, and thus it is assumed that the environment will correctly invert the output, $c$, to produce these input signals.
%
%Using the list of concepts found in Figure~\ref{fig:c-element-concepts}, we can find the set and reset functions for the only output signal $c$.
%
%\vspace{2mm}
%\begin{minipage}[t]{1\columnwidth}%
%\begin{center}
%$\,c^{+}: a * b$
%\par\end{center}
%
%\begin{center}
%$\,c^{-}: \bar{a} * \bar{b}$
%\par\end{center}
%
%\end{minipage}\vspace{2mm}
%
%These functions are fairly simple in this example, and there are no further simplification to be done, and thus these can be used for synthesis. In this case, as we are aiming to use a
%C-element in the implementation, and thus we can use C-element synthesis. The synthesis of this will produce the implementation found in Figure~\ref{fig:c-element-gate}
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.65]{Images/C-element-gate}
%\par\end{centering}
%
%\begin{centering}
%\protect\caption{\label{fig:c-element-gate}Implementation of C-element with environment}
%
%\par\end{centering}
%
%\end{figure}

%%+ Algorithm for translating concepts to STGs
%%
%%+ Using parallel and scenario composition to produce STGs for the whole system
%%
%%+ Direct synthesis from concepts
%\section{NEED TO REMOVE: Synthesis of STGs from concepts \label{sec:Synthesis-of-STGs}}
%
%\vspace{-3mm}
%\textbf{This section needs to be edited to be included in section \ref{sec: interop-with-stg}}
%
%\vspace{5mm}
%
%When a list of concepts is produced, we then pass this into an algorithm
%which converts these into a single scenario STG that, if possible,
%satisfies all of the concepts. This STG represents one operational
%mode of a full specification, and this needs to be combined with other
%scenario STGs in order to produce a full system specification. In
%this section we will discuss how this process is performed, from concepts,
%to a set of scenario STGs, to a full system model.
%
%\vspace{-2mm}
%
%
%
%\subsection{Deriving STG fragments from concepts}
%
%\vspace{-2mm}
%
%
%The algorithm begins by expanding any predefined concepts, and this
%returns a full list of concepts. Each concept can then be converted
%into its own STG fragment. In some cases, a single concept can represent
%a single STG fragment, but if a one-to-many concept is used, multiple
%fragments can be produced. These fragments are all created and stored
%for use in the next step, but hidden from the user. However, how the
%fragments are produced is important. For example, an STG fragment
%converted from the concept \textsf{\textit{\emph{outputRise}}} in
%the above C-element example is shown in Figure~\ref{fig:outputRise STG}.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/outputRise-stg}
%\par\end{centering}
%
%\protect\caption{\label{fig:outputRise STG}STG for the \textsf{\textit{\emph{outputRise}}}
%concept.}
%\end{figure}
%
%
%This STG features arcs which suggest that \textsf{$a^{+}$} and $b^{+}$
%must occur before \textsf{$c^{+}$}, as the concept suggests. This
%fragment can also be seen as part of the scenario STG in Figure~\ref{fig:cElement STG}.
%This concept however features two back-pressure arcs which are not
%necessarily described in the concept. In order for fragments created
%from concepts to be usable in producing scenario STGs, they need to
%be complete, meaning they must have initial states, displayed using
%tokens, and must not reach deadlock at any point, and this STG would
%be incomplete without these back-pressure arcs used to show initial
%states. These arcs are produced automatically by the algorithm, and
%these fragments may be hidden from the user.
%
%\vspace{-3mm}
%
%
%
%\subsection{Scenario STGs}
%
%\vspace{-2mm}
%
%
%If all concepts can be correctly converted into STG fragments, then
%they can then be used to produce the STG for the scenario. This process
%is done using a tool integrated in \noun{Workcraft} called \noun{Pcomp~}\cite{PCOMP},
%which is designed to compose multiple STGs. The algorithm will automatically
%take all STG fragments and pass them into the \noun{Pcomp} tool, and
%this returns a single STG, created by composing all of the fragments.
%It is necessary for all STG fragments to be complete, for example
%using back-pressure arcs and including the initial states, as this
%is used in the parallel composition process.
%
%We can use this process to produce STGs for scenarios, which are then
%verified and simulated in \noun{Workcraft} and used in the next step.
%However, if this STG is not to be used as a scenario but as a predefined
%concept, this can be verified and stored for further use as part of
%scenario descriptions.
%
%\vspace{-3mm}
%
%
%
%\subsection{Combination of scenarios \label{sub:Combination-of-scenarios}}
%
%\vspace{-3mm}
%
%
%When a scenario STG has been produced and verified, it can then be
%combined with other scenarios to produce a complete circuit specification.
%
%When combining scenarios, there are several things to consider in
%how the scenarios fit together. Depending on the application the circuit
%is being designed for, some scenarios may need to operate in certain
%orders, for example, one scenario may exist simply to initialise the
%circuit, therefore this scenario needs to run at start-up, before
%any of the other scenarios, and then never be run again while the
%system remains active.
%
%To address this, when combining scenarios we offer some templates,
%each of which can be used to combine scenarios in various orders.
%With this the designer specifies in which ways the scenarios should
%be combined, and if an order is needed, the order the scenarios should
%be run from start up. The following are some examples of templates
%that will be offered before scenarios are combined:
%
%\textbf{Sequential:} Sequential combination will allow a designer
%to select the order of all scenarios, so when combined, they will
%run in a sequence. In this case, there may be a clear order in which
%the scenarios may run, and this needs to be specified by the designer.
%
%\textbf{Concurrent:} In this case there is no order, but one or more
%of the scenarios in a specification may run in parallel. This template
%will combine the scenarios in a way that will allow concurrency to
%occur, limited to requirements of the specification, for instance,
%the number of scenarios that can be active at any one time, which
%can be limited by the number of tokens available at once.
%
%\textbf{Non-deterministic choice:} This template will combine the
%scenarios in a way that allows any of the scenarios to run, but not
%according to any order to deal with the lack of determinism in the
%system, using one token which is used only by the running scenario,
%and this is returned when the scenario completes.
%
%There may be some more complex requirements to combination, and it
%is possible to combine some scenarios using one template, then including
%the result in a combination using another template. For example, a
%system which is non-deterministic may also have a scenario that runs
%at start up to initialise the system. In this case, a designer could
%combine all non-deterministic scenarios first, then combine the resulting
%STG with the initialising scenario, setting the order so this runs
%first.
%
%This method of combination can allow for many possible scenario combination
%styles, and more complex systems can be combined automatically, which
%in comparison to manual combination, could reduce the number of errors
%as well as design time.
%
%\vspace{-3mm}
%
%

\section{Case study \label{sec:case-study}}

In Section~\ref{sec:Motivating Example} we introduced the example for this case study, a simple buck converter,
in order to discuss the monolithic approach to specifying asynchronous circuits. We have also introduced concepts in Section~\ref{sec:Concepts},
and with examples explained how they can be used to design simple circuits, and how these can be translated to
provide us with an STG specification for use with standard tools.

Now we can use this information with the buck converter case study to detail the design flow for producing a
specification for a buck converter.

\subsection{Formal specification using concepts}

From the informal buck specification and our knowledge of the signals,
we can determine three separate operating conditions that occur in
the analogue circuit and the controller needs to react to. All of
these can be produced from concepts separately and composed to produce
scenario STGs, before combining these to produce a single full circuit
STG.

During this process, it is useful to find any operations which occur
between two or more operational modes, as these can then be reused
in other scenarios. If this is defined in one list of concepts, it
can then be referenced in concept lists for other scenarios by name, assuming these scenarios will be built as part of the same workspace.

\subsubsection{ZC~absent scenario}

We start with describing the operational mode where no ZC condition
is signalled and produce the following list of concepts:

\begin{minipage}[h]{1\columnwidth}%

\begin{flushleft}
$\begin{aligned}\mathsf{circuit}&\,uv \,oc \,zc \,gp\_ack \,gn\_ack \,gp \,gn= \\
& \,\mathsf{chargeFunc}\,\diamond\,\mathsf{uvFunc}\,\diamond\,\mathsf{uvReact}\,\diamond
\,\mathsf{zcAbsent}
\end{aligned}
$
\par\end{flushleft}%

\par\begin{flushleft}
$\mathsf{where}$
\par\end{flushleft}

\begin{flushleft}
$\begin{aligned}\mathsf{interface}=\,&\mathsf{inputs}\,[uv, oc, zc, gp\_ack, gn\_ack]\\
& \,\diamond \mathsf{outputs}\,[gp, gn]
\end{aligned}$
\par\end{flushleft}%

\begin{flushleft}
$\,\mathsf{uvFunc}=uv^{+}\rightsquigarrow gp^{+}\,\diamond\, uv^{+}\rightsquigarrow gn^{-}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{ocFunc}=oc^{+}\rightsquigarrow gp^{-}\,\diamond\, oc^{+}\rightsquigarrow gn^{+}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{uvReact}=gp\_ack^{+}\rightsquigarrow uv^{-}\,\diamond\, gn\_ack^{-}\rightsquigarrow uv^{-}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{ocReact}=gp\_ack^{-}\rightsquigarrow oc^{-}\,\diamond\, gn\_ack^{+}\rightsquigarrow oc^{-}$
\par\end{flushleft}

\begin{flushleft}
$\begin{aligned}\,\mathsf{environmentConstraint}=&\,\mathsf{me}\,uv\, oc \,\diamond\, gn\_ack^{-}\rightsquigarrow gp^{+}\\ &\,\diamond\, gp\_ack^{-}\rightsquigarrow gn^{+}
\end{aligned}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{\mathsf{circuitConstraint}}=\mathsf{me}\,gn\, gp$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{gpHandshake}=\mathsf{handshake}\,gp\,gp\_ack$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{gnHandshake}=\mathsf{handshake}\, gn\, gn\_ack$
\par\end{flushleft}

\begin{flushleft}
$\mathsf{initialState}=\mathsf{initialise0}[uv,\, oc,\, zc,\, gp\_ack,\, gn\_ack,\, gp,\, gn]$
%initialState = initialise0 [uv, oc, zc, gp_ack, gn_ack, gp, gn]
\par\end{flushleft}

\begin{flushleft}
$\begin{aligned}\mathsf{chargeFunc}= & \mathsf{interface}\,\diamond\,\mathsf{ocFunc}\,\diamond\,\mathsf{ocReact}\,\diamond\\
 & \mathsf{\mathsf{\, environmentConstraint}\,\diamond\, circuitConstraint}\,\diamond\,\\
 & \mathsf{\, gpHandshake}\,\diamond\,\mathsf{gnHandshake}\,\diamond\,\mathsf{initialState}
\end{aligned}
$
\par\end{flushleft}

%\begin{flushleft}
%$\,\mathsf{zcAbsent}=\mathsf{silent}\,zc^{+}\,\diamond\,\mathsf{silent}\,zc^{-}$
%\par\end{flushleft}

\end{minipage}

\begin{flushleft}
\begin{figure}[H]
\begin{centering}
\includegraphics[scale=0.22]{Images/stg-UV_without_ZC}
\par\end{centering}

\protect\caption{\label{fig:zcAbsentScenario STG} STG for the \textsf{zcAbsentScenario}
concept.}
\end{figure}

\par\end{flushleft}

In this list, we introduce concepts which describe the correction
of both under-voltage and over-current. This includes concepts describing
handshakes for $gp/gp\_ack$ and $gn/gn\_ack$, and transistor safety
constraints which are described using protocol-level concepts. We
also describe constraints provided by the environment that we are
aware of, such as $oc$ and $uv$ never signalling at the same time, and ensuring that
the acknowledge signal of transistors must be low before the other transistor can be switched on.
Environment behaviour is included in the concepts so that it is captured in the resulting STG for testing and simulation purposes.
We also include an \textsf{interface} concept in order to include the
types of the signals involved in the scenario.

The descriptions of the operational modes suggest that there are similarities
between them, mainly in the sequence of PMOS/NMOS activation during
the charging cycle. The signal types are also the same for all scenarios in the system, and
thus it is unnecessary to redefine these for each scenario.
Therefore it is natural to define a \textsf{chargeFunc}
concept that can be reused when other operation modes are specified.

%We also include for this scenario a~\emph{zcAbscent} concept.
%This uses the silent concept for both $zc^{+}$ and $zc^{-}$ to indicate
%that in this system, there is a signal $zc$ but it has no bearing on the scenario.

Figure~\ref{fig:zcAbsentScenario STG} shows the STG produced from
the final concept in the list, \textsf{zcAbsentScenario}. It contains
two tokens which are created based on the \textsf{initialState} concept.
The analogue circuit is not guaranteed to signal either under-voltage
or over-current first, and this needs to be noted in the concepts
and the STG.

\subsubsection{ZC~late scenario}

In this operational mode we have to include zero-crossing, as per
the specification. However, in this case under-voltage and over-current
are corrected in the same way as in the no~ZC scenario, as zero-crossing has no effect when it signals after UV, and therefore
we can include the \textsf{zcAbsentScenario} concept. We still need
to describe the interactions involving zero-crossing, as well as it's initial state. The concepts
are as follows:

\begin{minipage}[t]{1\columnwidth}%
\begin{flushleft}
$\begin{aligned}\\\mathsf{circuit}&\,uv \,oc \,zc \,gp\_ack \,gn\_ack \,gp \,gn = \\
& \mathsf{\, chargeFunc}\,\diamond\,\mathsf{uvFunc}\,\diamond\,\mathsf{uvReact}\,\diamond\\
& \,\mathsf{zcLate}\,\diamond\,\mathsf{initialise}\,zc\,\,False
\end{aligned}
$
\par\end{flushleft}%

\par\begin{flushleft}
$\mathsf{where}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{zcLate}=uv^{+}\rightsquigarrow zc^{+}\,\diamond\, zc^{-}\rightsquigarrow uv^{-}$
\par\end{flushleft}

\end{minipage}

\begin{figure}[H]
\begin{centering}
\includegraphics[scale=0.22]{Images/stg-UV_before_ZC}
\par\end{centering}

\protect\caption{\label{fig:zcLateScenario STG}STG for the \textsf{zcLateScenario}
concept.}

\end{figure}

Figure~\ref{fig:zcLateScenario STG} shows the STG produced, which
looks similar to the STG in Figure~\ref{fig:zcAbsentScenario STG}
but this features a branch from some $uv$ and $zc$ interaction.
This is defined in the concept \textsf{zcLateScenario}, which does
not describe the arc $zc^{+}\rightsquigarrow zc^{-}$ but this consistency
is implied at translation time by consistency loops.

\subsubsection{ZC~early scenario}

The \textsf{chargeFunc} concept can be reused, as the PMOS/NMOS transistors
are still operated in the same way. However, the interplay between
the early zero-crossing and under-voltage needs to be specified with
several new concepts:

\begin{onehalfspace}
\begin{minipage}[t]{1\columnwidth}%

\begin{flushleft}
$\begin{aligned}\mathsf{circuit}&\,uv \,oc \,zc \,gp\_ack \,gn\_ack \,gp \,gn= \\ &\,\mathsf{chargeFunc}\,\diamond\,\mathsf{zcFunc}\,\diamond\,\mathsf{zcReact}\,\diamond\\
& \,\mathsf{uvFunc'}\,\diamond\,\mathsf{uvReact'}\,\diamond\,\mathsf{initialise}\,zc\,\,False
\end{aligned}
$
\par\end{flushleft}%

\begin{flushleft}
$\mathsf{where}$
\end{flushleft}

\begin{flushleft}
$\,\mathsf{zcFunc}=zc^{+}\rightsquigarrow gn^{-}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{zcReact}=oc^{-}\rightsquigarrow zc^{+}\,\diamond\, gp^{+}\rightsquigarrow zc^{-}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{uvFunc'}=uv^{+}\rightsquigarrow gp^{+}$
\par\end{flushleft}

\begin{flushleft}
$\,\mathsf{uvReact'}=zc^{+}\rightsquigarrow uv^{+}\diamond\, zc^{-}\rightsquigarrow uv^{-}\diamond\, gp\_ack^{+}\rightsquigarrow uv^{-}$
\par\end{flushleft}

\end{minipage}
\end{onehalfspace}

\begin{center}
\begin{figure}[H]
\begin{centering}
\includegraphics[scale=0.22]{Images/stg-UV_after_ZC}
\par\end{centering}

\protect\caption{\label{fig:zcEarlyScenario STG}STG for the \textsf{zcEarlyScenario}
concept.}
\end{figure}

\par\end{center}

%\vspace{-8mm}

The obtained STG for the \textsf{zcEarlyScenario} concept is shown
in Figure~\ref{fig:zcEarlyScenario STG}. We have now produced three
scenario STGs, one for each operational mode in this system. However,
we need to ensure they are correct both for the specification and
as STG models before we can combine these.

%\subsection{Verification and simulation of scenarios \label{sub:Verification-and-simulation}}
%
%%\vspace{-2mm}
%
%To be combinable by our method, the produced STGs need to satisfy certain
%properties~\cite{Cortadella}:
%\begin{itemize}
%\item Complete State Coding (CSC): each state of the models with different
%behaviour has differing signal encodings to avoid problems during
%synthesis. Note that in some cases it is possible to automatically
%resolve a CSC conflict.
%\item Deadlock freedom: no state is reachable from which no progress can
%be made.
%\item Output persistence: there are no race conditions in the STG.
%\item Signal consistency: in any trace the rising and falling phases of
%each signal alternate.
%\end{itemize}
%These properties can be automatically checked in \noun{Workcraft }using
%the \noun{Mpsat}~\cite{khomenko2004detecting} backend tool\noun{.
%}In the event that one of these properties does not hold, unless it
%can be corrected automatically, which \noun{Mpsat} can attempt, the combination of scenarios fails.
%In this case a problematic concept is identified and diagnostic information
%is printed out to help a designer correct the issue.
%
%Correctly produced scenarios may not necessarily work as the specification
%suggests, and this needs to be validated before using these scenarios
%in any further designs. \noun{Workcraft} features a simulation tool,
%and this can be used by a designer to check that the signals can transition
%according to the initial requirements. If the simulation produces
%undesirable results, a designer can work to fix the error of the scenario
%STG, or correct the design at the concept level. The latter is the
%preferable method if this design is to be reused either as a predefined
%concept, or as a scenario in another system.

%\vspace{-2mm}

\subsection{Combining the scenarios }

%\vspace{-2mm}

Now we have scenario STGs that have been verified to ensure they conform
to standards required of STGs, and simulated to ensure they work as
expected according to the specification. These can now be combined
to produce a full system implementation. As mentioned in Section~\ref{sub:scenario-composition},
we can combine these scenarios in multiple ways, depending on whether
there is some sort of required ordering to the way these scenarios
must run.

For a simple buck controller there is no required order of running
these scenarios, and it is uncertain as to which scenario may be running
at any one time. Therefore, the best solution for this system is to
combine all of the scenarios in a non-deterministic fashion. The full
system implementation produced should allow for only one of these
scenarios to run at a time, but when the scenario has completed the
system should return to a state where any of the scenarios could run
again, regardless of which solution ran previously.

\begin{figure}[t]
\begin{centering}
\includegraphics[scale=0.22]{Images/stg-buck-scenarios_merged}
\par\end{centering}

\begin{centering}
\protect\caption{\label{fig:buck STG}Complete STG for a buck converter.}

\par\end{centering}

\end{figure}

Figure~\ref{fig:buck STG} shows the full system specification STG
that has been produced from combining the three scenario STGs as seen
in Figures~\ref{fig:zcAbsentScenario STG},~\ref{fig:zcLateScenario STG},
and~\ref{fig:zcEarlyScenario STG}. It is possible to view each individual
scenario in the system in this STG. There are redundancies iuncluded in
this STG, which can merged with other parts of the STG
to produce a more compact model. This would produce an STG
similar to that shown in Figure~\ref{fig:Monolithic-buck}.  It is a trivial
step to simplify the STG, as these are functionally the same, and
produce the same results during verification and synthesis.

There is an explicit place in this model which holds a token initially,
and this allows any of the scenarios to run. This place has no
control over which scenario can run, but it only allows one of
them to run at a time. The single token is consumed
by whichever scenario runs, and the lack of token in the place
after this stops any more scenarios running. The token is passed through
the scenario, and after over-current is corrected the token is passed
back into this place, allowing only one of the scenarios to run again.

%\vspace{-3mm}

\subsection{Verification and simulation}

%\vspace{-3mm}

To be combinable by our method, the produced scenario STGs need to satisfy certain
properties~\cite{Cortadella}:
\begin{itemize}
\item Complete State Coding (CSC): each state of the models with different
behaviour has differing signal encodings to avoid problems during
synthesis. Note that in some cases it is possible to automatically
resolve a CSC conflict.
\item Deadlock freedom: no state is reachable from which no progress can
be made.
\item Output persistence: there are no race conditions in the STG.
\item Signal consistency: in any trace the rising and falling phases of
each signal alternate.
\end{itemize}
These properties can be automatically checked in \noun{Workcraft }using
the \noun{Mpsat}~\cite{khomenko2004detecting} backend tool\noun{.
}In the event that one of these properties does not hold, unless it
can be corrected automatically, which \noun{Mpsat} can attempt, the combination of scenarios fails.
In this case a problematic concept can be identified and diagnostic information
is printed out to help a designer correct the issue.

Correctly produced scenarios may not necessarily work as the specification
suggests, and this needs to be validated before using these scenarios
in any further designs. \noun{Workcraft} features a simulation tool,
and this can be used by a designer to check that the signals can transition
according to the initial requirements. If the simulation produces
undesirable results, a designer can work to fix the error of the scenario
STG, or correct the design at the concept level. The latter is the
preferable method if this design is to be reused either as a predefined
concept, or as a scenario in another system.

After all scenarios have been combined, the result will be the STG specification
for the full system. If each scenario used in the combination process satisfies
the verification properties, it is possible no errors will exist within the full
specification. However, certain unforeseen errors may be produced
and thus, it is necessary to verify the resulting specification. This can
be performed using \noun{Mpsat} as with the scenarios to ensure the same
properties are held. The simulation tool built into \noun{Workcraft} can also
be utilised for testing the functionality of a full system specification.

%Like with the scenario models when they have been composed, we need
%to verify that this model satisfies certain properties after combination
%of multiple scenarios, as any issues at this stage will cause an implementation
%of the model to be wrong and this can cause the model to be unimplementable
%as an SI circuit.
%
%The verification properties we need to satisfy are the same as for
%scenarios~(see~Section~\ref{sub:Verification-and-simulation}),
%and are corrected in similar ways, however the corrections can be
%done within the problematic scenario, by changing, adding or removing
%one or more concepts to avoid affecting any of the functionality of
%the whole system, or any of the correctly functioning scenarios.
%
%When the full system model satisfies all of the verification properties,
%we can simulate this model and check that the signals can transition
%in the order we expect according to the requirements of the system.
%If this is correct, we can guarantee that this model represents the
%full system specification, and can now be used in the next step.

%\vspace{-2.5mm}

\subsection{Synthesis of a speed-independent controller}

%\vspace{-2.5mm}

A fully working model of the system is only part way to having completed
the process. The final step in this design flow is to synthesize this
specification. Synthesis is the process of finding Boolean equations to calculate
the next state of the output signals based on the input signals and
the current state of the circuit~\cite{Cortadella}. We can do this
using \noun{Petrify} or \noun{Mpsat}, both of which are integrated
in \noun{Workcraft}. Passing this model through one of these tools
will produce logic equations that describe how the outputs $gp$ and
$gn$ can be produced using $uv$, $oc$, $zc$, $gp\_ack$, $gn\_ack$.
Using logic gates, we can reproduce a circuit diagram for these equations.
Figure~\ref{fig:buck Circuit} shows the logic circuit, synthesized
from this full model.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.3]{Images/circuit-buck}
\par\end{centering}

\protect\caption{\label{fig:buck Circuit}Asynchronous logic gate implementation}
\end{figure}

When we have acquired a circuit design, it needs to be verified to
ensure that the logic will perform as we expected before the circuit
is fabricated. To verify this, the circuit is converted into a so-called
circuit Petri net, using a model for each logic gate and combining
them by means of read-arcs. By reachability analysis of this Petri
net one can verify that the corresponding circuit is deadlock-free,
hazard-free and conforms to the specification~\cite{2008_poliakov_async}.

%\vspace{-2mm}

\section{Related work\label{sec:related-work}}

There are several existing methodologies which are similar to the
one being proposed in this paper, and there are a common set of features between these which can be compared.
In some cases, these cannot be used for asynchronous designs, but some of their other key features can still be compared.
Table~\ref{tab:related_work} contains a comparison of these features.

We have found these related works limited in
certain aspects, and we discuss this below.
\begin{table*}[t]
\caption{A comparison of features of related works and the proposed method \label{tab:related_work}}
  \centering
  \begin{tabular}[htb]{| m{1.5cm} | m{2cm} | m{1.3cm} | m{1.75cm} | m{1.5cm} | m{1.5cm} | m{1.7cm} | m{1.15cm} |}
  \hline
  Title                       & \,Asynchronous support & \,Tool support  & \,Composition & \,Gate-level design & \,Event-level design & \,Protocol-level design  & \,Design focus \\ \hline \hline
  Concepts              & Yes                               & Yes                 & Yes               & Yes                       & Yes                         & Yes                              & \,Little digital \\ \hline
  Balsa                     & Yes                               & Yes                 & No                & Yes                       & No                          & Yes                              & \,Big\,\,\,\, digital \\ \hline
  Biscotti                  & Yes                               & Yes                 & No                & Yes                       & No                           & No                               & \,Big\,\,\,\, digital \\ \hline
  Lava                      & Yes                               & Yes                 & No                & Yes                       & No                           & Yes                             & \,Big\,\,\,\, digital \\ \hline
  C$\lambda$ash     & Yes                               & Yes                 & No                & Yes                       & No                           & Yes                             & \,Big\,\,\,\, digital \\ \hline
  Snippets                & No                                & No                   & Yes               & No                        & No                          & No                                & \,Little digital \\ \hline
  DI algebra             & Yes                               & No                   & Yes               & No                        & Yes                         & No                               & \,Little digital \\ \hline
  Structural design   & No                                & Yes                 & No                 & No                        & No                          & No                               & \,Modular circuits \\ \hline
  \end{tabular}
\end{table*}

A common approach of designing asynchronous circuits, \textbf{Balsa}~\cite{edwards2002balsa}, uses an RTL language to specify operations for asynchronous circuits for both big-
digital, data featuring multiple bits, and little-digital, control systems. A Balsa specification is initially converted into format describing a network of handshaked components, which can be
used for simulation and circuit diagrams. This can then be used in synthesis, by mapping handshaked components on to library components~\cite{van1993handshake}. RTL languages
are used for synchronous design, and thus designers can adapt to Balsa more easily, however specifying a control system can lead to a complicated program which can be difficult to
comprehend, in comparison to the STGs produced in the proposed approach, in which signal interactions can be visualised.

\textbf{Biscotti}~\cite{5232351} is an approach which uses a C-style language, which can be easy to adapt to as designers are likely to have programming experience. It features
\emph{forever} blocks, in which code runs sequentially, but all these blocks run concurrently to each other. This design method starts by specifying a circuit which is then
\emph{compiled} into a Petri-net for verification with existing tools including \noun{Workcraft} and if successful, synthesis, similar to our approach with conversion of concepts to allow
use with multiple existing tools based on STGs. Biscotti is aimed at designing data-driven asynchronous systems however, and as with Balsa, specifying an asynchronous control system is
complex and difficult, especially as the number of signals involved increases.

\cite{bjesse1998lava} introduces \textbf{Lava}, a Haskell tool. This features its own design flow, using predefined functions for structures like logic gates, allowing users to define
functions using these structures. A collection of these functions can be used to design a circuit and be verified within Lava, however for steps such as simulation and synthesis, Lava
generates VHDL code to be used by other software. This has similar ideals to concepts, allowing users to define functions from predefined structures, which can be reused. However,
Lava is more focussed on designing asynchronous circuits for data operations featuring wires with multiple bit widths, rather than asynchronous control systems. Concepts are also
focussed on more than just logic gates, and allows definitions both as standard and user-defined at multiple levels; signal-, gate-, protocol- and scenario-level.

\textbf{C$\lambda$ash}, introduced in~\cite{baaij2009clambdaash},  is also a Haskell based tool, similar to Lava, focussed on asynchronous data circuits.  It has some cross-over
features with Lava, such as built-in verification, and the ability for users to define functions. C$\lambda$ash, however, uses existing Haskell constructs to directly synthesize as
asynchronous operations. C$\lambda$ash also features built in synthesis and simulation, avoiding the need to export VHDL, however this feature remains. This allows a simpler way of
specifying operations for asynchronous circuits, which may be more natural for designers, however Haskell as a language features huge differences to programming languages like
\noun{C}. The idea of a natural description is shared with Concepts, but as with Lava, the main focus is on logic gates, and other high level descriptions, where as Concepts allow
multiple levels, from low to high, when specifying.

\textbf{Snippets}~\cite{raey}, similar to concepts, are smaller
state graph models which are used to compose full state graphs of
larger systems. Snippets describe the operation of a part of a system
in terms of input and output alphabets, and in which ways these snippets
can fail. When composed with other snippets it can produce a working
system state graph model. With our design methodology however we want
to go deeper and decompose a component into concepts responsible for
capturing signal behaviours for system features, such as handshakes,
mutual exclusion, synchronisation, etc.

\textbf{DI algebra}~\cite{josephs1993overview} is a method of describing
systems as algebraic equations. Each equation represents an operation
of the specification, similar to scenarios, and composing these can
be simplified for the most compact version of the equation. These
can then be composed to find an equation for the whole specification
and again simplified for the most compact version. Our method is similar
to DI algebra, however concepts are described textually, which is
different to DI algebra and as such, simplification does not occur
at concept level, but during the composition and combination steps,
and the most compact form of the model is automatically produced.
To the best of our knowledge there are no tools or methodologies supporting
compositional design of asynchronous circuits using DI algebra and
it is therefore not interoperable with the rest of our design flow,
and this also makes it unsuitable for use in an industrial setting.

\textbf{Structural design} features re-usability of modular components~\cite{modular-circuit-design}.
Here, a component design can be used multiple times across full device
designs in conjunction with several other circuit modules. These modules
can be changed in some way without affecting how they are used in
the full device designs. The ideas of this method are similar to that
of the design methodology we are proposing to reduce design time.
However, this method is at a much higher level, using fully designed
and tested components where as we propose to allow re-usability when
modelling at circuit level, using composed concepts.

Concepts have many beneficial features, such as reuse, natural description, multiple level description and composition, and more. Several of the discussed approaches feature similar
ideas which make them beneficial in certain ways, but we believe fall down at points where the inclusion of one or more of these features could make an approach better. With concepts,
we have attempted to address these issues and make concepts not only a powerful tool to specify asynchronous circuits, but a method with as much ease-of-use as possible.

%\textbf{Resynthesis}~\cite{Resynth2} is a process of decomposing
%a full model and recomposing it of selective components to produce
%a smaller model. This can be used to reduce the number of signals
%to connect two separate models for example. This process is regularly
%used for optimisation of Balsa control circuits~\cite{plana2005attacking},
%however in Balsa the set of predefined components is fixed, so a designer
%cannot easily introduce new scenarios. Resynthesis also requires full
%models which can be decomposed. This requirement may be problematic
%for the proposed methodology as we take a ground-up approach to composition,
%starting with primitive concepts which composed into scenarios, which
%are subsequently combined into a complete model. Resynthesis can still
%be used at a later stage of the design process, once the complete
%model of a system~(or a subsystem) has been obtained using the proposed
%methodology.

\section{Conclusions and future work\label{sec:conclusions}}

In this work we show that it is possible to design a system by splitting
it into operational modes, and describing signal interactions and requirements
of the mode in a textual format. These can then be used to produce STGs
that represent these operational modes, which can be combined to
produce a model for the full system specification.

Using concepts, a user can reduce the time of designing an asynchronous
control circuit from the ground up, as well as allow reuse of components
either as part of a scenario or entire scenarios to reduce the design-time
of future projects. Composition of concepts and scenarios can help
reduce errors and save time in comparison to performing these manually.
This method can help to make asynchronous circuits more appealing
to industrial designers.

As the Internet-of-Things becomes more apparent, asynchronous circuits
will be key in designing nodes, for quick and efficient power management
to increase the operation time of these devices.

Currently, this method works with Signal Transition Graphs, however
it can be applied to other modelling disciplines, such as Finite State
Machines~(FSM). In addition to FSMs and STGs, we also plan to extend
this design method to support Conditional Partial Order
Graphs~(CPOGs)~\cite{CPOG1} and Parameterised
Graphs~\cite{mokhov2014algebra} for modelling asynchronous circuits.
CPOGs can also be used for process mining, using tools such as
\noun{PGminer}~\cite{mokhov_2016_mining}\cite{pgminer}. Process mining
can be used for various purposes in conjunction with designing
asynchronous circuits. For example, process mining can find a
behavioural model if non exists, and can be
used to check that an existing specification is realistic, or find less
complex models. All of this can be performed automatically, and aid a
designer in reducing design time and errors.

%In some cases, a designer may wish to view a scenario
%or full system model as an FSM as they can provide more information
%about a system, which can help with editing finer details of system,
%or when correcting errors. It could be possible to use concepts to
%create scenario FSMs that could then be combined to produce a full system
%model in FSM form.


CPOG and Parameterised Graph models are also integrated into
\noun{Workcraft}~\cite{Workcraft_website} as part of the \noun{Scenco} toolsuite~\cite{2015_workcraft_scenco}~\cite{Scenco_paper},
allowing circuits to be described by algebraic equations in text
form. \noun{Scenco} provides support for describing concept models
to produce scenarios and then compose scenarios to produce full system
implementations.

%In certain cases, an implementation may need to be changed based on
%design parameters to produce the best result, and these may change
%during run-time or after the fabrication stage. CPOGs support parameter
%and run-time reconfigurability~\cite{microadapt}, hence if
%design parameters change, the design does not need to be recomposed
%from another list of concepts, thus saving time. For this reason,
%CPOGs could work very well with this design approach.

In certain cases, an implementation may need to be changed based on
design parameters to produce the best result, and these may change
during run-time or after the fabrication stage. CPOGs support parameter
and run-time reconfigurability~\cite{microadapt}, hence if
design parameters change, the design does not need to be recomposed
from another list of concepts, thus saving time. For this reason,
CPOGs could work very well with this design approach.

STGs and CPOGs both have their benefits when working with asynchronous
systems, and it will be useful to compare these two methods, to see
if either is better when designing a system from concepts, or see
if there are certain specifications where one modelling method is
better than the other. It may be necessary to have a form of interaction between CPOGs and STGs in order to provide a more streamlined method of designing asynchronous circuits
using concepts, and this is something we aim to explore.

%\vspace{-2mm}

%
%In addition to FSMs and STGs, we also plan to extend this design method
%to support Conditional Partial Order Graphs~(CPOGs)~\cite{CPOG1}
%and Parameterised Graphs~\cite{mokhov2014algebra} for modelling
%asynchronous circuits. These models are also integrated into \noun{Workcraft}
%as part of the \noun{Scenco} toolsuite\noun{~\cite{2015_workcraft_scenco},
%}allowing circuits to be described by algebraic equations in text
%form. \noun{Scenco} provides support for describing concept models
%to produce scenarios and then compose scenarios to produce full system
%implementations.
%
%CPOGs can also be used for process mining, using tools such as \noun{PGminer}~\cite{mokhov_2016_mining, pgminer}.
%Process mining can be used for various purposes in conjunction with designing asynchronous circuits. For example, process mining can find a behavioural model if non exists, and can be
%used to check that an existing specification is realistic, or find less complex model. All of this can be performed automatically, and aid a designer in reducing design time and errors.
%

%\vspace{-3mm}

\section*{Acknowledgements}

%\vspace{-2.5mm}

The authors would like to thank the reviewers for their constructive
comments. This research is supported by EPSRC research grant `A4A:
Asynchronous design for Analogue electronics' (EP/L025507/1) and
the Royal Society research grant `Computation Alive: Design of a
Processor with Survival Instincts'.

%\vspace{-2.5mm}

\bibliographystyle{unsrt}
\bibliography{publications}

\end{document}
